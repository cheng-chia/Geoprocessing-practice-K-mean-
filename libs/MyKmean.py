# Name: Cheng-Chia (Karie) Huang

import sys, random
from MyPoint import Point

class MyKmeans:
    def __init__(self, k, num_points, dimension, lower_bound, upper_bound):
        self.k = k
        self.num_points = num_points
        self.dimension = dimension
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound
        self.points = []
        self.centroids = {}


    def get_parameter(self):
        k = int(raw_input("Enter number of k in k-means cluster: "))
        num_points = int(raw_input("Enter number of points: "))
        dimension = int(raw_input("Enter the dimension of randomly generated points: "))
        lower_bound = int(raw_input("Enter the lower bound of randomly generated point: "))
        upper_bound = int(raw_input("Enter the upper bound of randomly generated point: "))
        self.k = k
        self.num_points = num_points
        self.dimension = dimension
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound


    def generate_points(self):
    #def point_lst(num_point,dimension,lower_bound, upper_bound):  # Create a function that takes 4 parameters
        lst = []
        for p in range(self.num_points):
            if self.dimension == 2:   # if dimension ia two, create 2-D points, and append the point into lst
                newPoint = Point(2,(random.uniform(self.lower_bound,self.upper_bound),random.uniform(self.lower_bound,self.upper_bound)))
                lst.append(newPoint)

            if self.dimension == 3:  # if dimension is tree, create 3-D points, and append the point into lst
                newPoint = Point(3,(random.uniform(self.lower_bound,self.upper_bound),random.uniform(self.lower_bound,self.upper_bound),random.uniform(self.lower_bound,self.upper_bound)))
                lst.append(newPoint)

        self.points = lst


    def initialize_centroids(self):

        cluster_id = 1
        for point in random.sample(self.points, self.k):
            self.centroids[cluster_id] = point
            cluster_id += 1


    def assign_random_clust_number(self):

        for point in self.points:
            point.clust_id =  random.randint(1, self.k)


    def assign_clust_number(self):

        for i in self.points:       # go through all points in self.points which is a list of points generated by generate_points
            min_dist = sys.maxint   #initialize with maximum integer value

            for j in self.centroids:  # go through all points in self.centroid.
                dist = i.calc_distance(self.centroids[j])  # assign dist is the distance between point in self.points and points in self.centroid

                if(min_dist > dist): # if dist is smaller than min_dist
                    min_dist = dist  # assign min_dist is dist
                    i.clust_id = j   # assign the ID of the point in self.points is the ID of the centroid in self.centroids



    def check_same_coordinate(self,point1,point2):
        if point1.coordinate == point2.coordinate:
            return True
        else:
            return False



    def update_centroid(self):
        flag_all_same_coordinate = True
        # old_centroids = {}

        for cen in self.centroids:
            ref_centroid = self.centroids[cen]
            ref_clust_id = cen

            sum_x = 0
            sum_y = 0
            sum_z = 0
            n = 0


            for p in self.points:
                if p.clust_id == ref_clust_id:
                    sum_x += p.x
                    sum_y += p.y
                    sum_z += p.z
                    n += 1

            if len(self.points)>0:
                average_x = sum_x/n
                average_y = sum_y/n
                average_z = sum_z/n
                new_centroid = Point(3,(average_x,average_y,average_z),ref_clust_id)

                self.centroids[cen] = new_centroid  # update
                #if self.check_same_coordinate(new_centroid, ref_centroid) == False:   #check if the updated coordinate is the same as ref_centroid
                if new_centroid.coordinate != ref_centroid.coordinate:
                    flag_all_same_coordinate = False

            return flag_all_same_coordinate



# Plotting for 2-Dimension Kmenas
from matplotlib import pyplot as plt
import matplotlib.cm as cm

def plot_clust_points(mykmean, color_scale=10.0, pt_size=100, centroid_size=200, pt_marker="o", centroid_marker="x"):
    colors = []
    for i in range(mykmean.k):
        colors.append(cm.hsv(float(i)/color_scale))
    for i in mykmean.points:
        plt.scatter(i.x, i.y, c=colors[i.clust_id-1], marker=pt_marker, s=pt_size)
    for i in mykmean.centroids:
        pt = mykmean.centroids[i]
        plt.scatter(pt.x, pt.y, c=colors[pt.clust_id-1], marker=centroid_marker, s=centroid_size)
    plt.show()




# Extra: Plotting for 3-Dimension Kmenas
from mpl_toolkits.mplot3d import Axes3D
def plot_clust_points_3d(mykmean, color_scale=10.0, pt_size=100, centroid_size=200, pt_marker="o", centroid_marker="x"):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    colors = []
    for i in range(mykmean.k):
        colors.append(cm.hsv(float(i)/color_scale))
    for i in mykmean.points:
        ax.scatter(i.x, i.y, i.z, c=colors[i.clust_id-1], marker=pt_marker, s=pt_size)
    for i in mykmean.centroids:
        pt = mykmean.centroids[i]
        ax.scatter(pt.x, pt.y, pt.z, c=colors[pt.clust_id-1], marker=centroid_marker, s=centroid_size)

    ax.set_xlabel('X-Axis')
    ax.set_ylabel('Y-Axis')
    ax.set_zlabel('Z-Axis')
    plt.show()